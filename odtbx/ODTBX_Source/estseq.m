classdef estseq < estimator
%   ESTSEQ  Sequential Estimator.
%
%   [T,X,P] = ESTSEQ(DYNFUN,DATFUN,TSPAN,X0,P0) with TSPAN = [T0 TFINAL]
%   integrates the system of differential equations x' = f(t,x) from T0 to
%   TFINAL with initial conditions X0, then at TFINAL updates x with the
%   measurement generated by y = h(t,x) + v using a Kalman gain based on
%   propagation of the covariance matrix P0.  To obtain updates at multiple
%   times T1, T2, ..., TFINAL, use TSPAN = [T0 T1 T2 ... TFINAL].
%
%   Function [F,A,Q]=DYNFUN(T,X,options) must return a column vector 
%   corresponding to f(t,x). If DYNFUN is "vectorized," then f(t,x) must be
%   a 2-D array with each column corresponding to f(t(i),x(t(i)). Function 
%   DYNFUN(T,X) must return an additional output if called with two output
%   arguments, which may either be a matrix corresponding to A(t), or else 
%   an empty matrix, in which case INTEG will numerically compute A(t) with
%   NUMJAC. If A(t) is supplied, it must be a 3-D array for the vectorized
%   case, with each "slice" corresponding to A(t(i)).  To include process
%   noise, DYNFUN must return the process noise spectral density matrix, Q
%   = E[ww'], where x' = f(t,x) + w, as an additional output.  If DYNFUN is
%   vectorized, then Q must be a 3-D array, with each "slice" corresponding
%   to Q(t(i)).
%
%   Function [h,H,R]=DATFUN(T,X,options) must return a column vector 
%   corresponding to h(t,x), and two additional outputs corresponding to 
%   the measurement partials, H(t) = dh(t,x)/dx, and the measurement noise 
%   covariance, R = E[vv'], where y = h(t,x) + v.  As an alternate to 
%   supplying H(t), DATFUN may return an empty matrix as its second output, 
%   in which case ESTINV will numerically compute H(t) using NUMJAC. If 
%   DATFUN is "vectorized," then h(t,x) must return as its first output a 
%   2-D array with each column corresponding to h(t(i),x(t(i)); its next 
%   two outputs must be 3-D arrays with each "slice" corresponding to 
%   H(t(i)) and R(t(i)), respectively.
%
%   The rows in the solution array X correspond to times returned in the 
%   column vector T, which are chosen by the integrator.  The rows in the 
%   solution covariance array P correspond to the unique lower triangular 
%   elements of P at the times T, appended by row from column 1 to the main 
%   diagonal.  The Ith row may be reformed into a matrix using 
%   UNSCRUNCH(P(I,:)).
%
%   [T,X,P] = ESTSEQ(DYNFUN,DATFUN,TSPAN,X0), where P0 is not specified, 
%   uses the default initial covariance corresponding to a diagonal matrix 
%   of 1/eps.  
%
%   [T,X,P] = ESTSEQ(DYNFUN,DATFUN,TSPAN,X0,P0,OPTIONS) performs as above
%   with default properties replaced by values in OPTIONS, an argument
%   created with the SETODTBXOPTIONS function.  See ODTBXOPTIONS for
%   details. Commonly used options allow one to specify parameters or
%   features of the estimator, force model, and measurment model.  One of
%   estimator parameters is 'SchmidtKalman'.  This is the flag to use
%   the Schmidt Kalman filter instead of the standard Kalman filter in
%   ESTSEQ.
%
%   [T,X,P] = ESTSEQ(DYNFUN,DATFUN,TSPAN,X0,P0,OPTIONS,DYNARG,DATARG)
%   passes DYNARG to DYNFUN and DATARG to DATFUN as DYNFUN(T,X,DYNARG) and
%   DATFUN(T,X,DATARG), respectively.  Use OPTIONS = [] as a place holder
%   if no options are set.
%
%   [T,X,P] = ESTSEQ(DYNFUN,DATFUN,TSPAN,X0,P0,OPTIONS,DYNARG,DATARG,S,C)
%   passes in solve-for and consider mapping matrices, S and C,
%   respectively.  These matrices partition the state into a solve-for
%   partition, S*x, and a consider partition, C*x.  Only parameters in the
%   former partition will be updated from the meaurements.  Use [] as a 
%   place holder for OPTIONS, DYNARG, and/or DATARG as necessary if these 
%   inputs are not required.  S and C can be 2-D or 3-D arrays.  If 3-D, 
%   the 3rd dimension corresponds to the time vector. However, time-
%   varying S and C are currently not implemented; therefore, constant S 
%   and C corresponding to the first time vector will be used.
%
%   To handle the different dimensions of the full state vs. the solve-
%   for and consider partitions, the user can either design DYNFUN and 
%   DATFUN to check for this, or specify DYNFUN and/or DATFUN as 
%   structures, whose fields are *.tru and *.est. The function specified 
%   in *.tru will be used to evaluate the full state, and the one in 
%   *.est will be used for the solve-for partition.  This is also a way 
%   to specify differences between the true and the estimator models of the
%   dynamics and the measurement data.  Similar conventions may be used 
%   for X0, P0, DYNARG, and DATARG, i.e. X0.Xo and X0.Xbaro, P0.Po and 
%   P0.Pbaro, DYNARG.tru and DYNARG.est, DATARG.tru and DATARG.est. 
%
%   [T,X,P,E] = ESTSEQ(DYNFUN,DATFUN,TSPAN,X0,P0,...) also returns the
%   estimation errors, E.
%
%   [T,X,P,E,DY,PA,PV,PW,PHATA,PHATV,PHATW] = ESTSEQ(...) returns the 
%   innovations, DY, and several addditional covariance matrices: PA, PV, 
%   and PW are the true covariances that arise only from the true  
%   _a priori_ covariance, the true measurement noise covariance, and the 
%   true process noise covariance, respectively;  PHATA, PHATV, PHATW are 
%   the estimator's covariances that arise only from the design values of 
%   the  _a priori_ covariance, the measurement noise covariance, and the 
%   process noise covariance.
%
%   [T,X,P,E,DY,PA,PV,PW,PHATA,PHATV,PHATW,SIGSA,EFLAG] = ESTSEQ(...) also
%   returns SIGSA, the sensitivity matrix of the solve-for states at each 
%   time step, as well as EFLAG, the array of edit flag values for all 
%   cases for all measurement types for all times. The edit flags may have 
%   the following values:
%
%       NaN = Measurement was not available.
%       0   = Measurement was rejected (based on the edit ratio settings)
%       2   = Measurement was forced to be accepted (based on edit flag
%             settings)
%
%   [T,X,P,E,DY,PA,PV,PW,PHATA,PHATV,PHATW,SIGSA,EFLAG,PDY,PDYT] = ESTSEQ(...) 
%   also returns the formal and the true covariance of the measurment 
%   innovations DY, where the former is computed from the Monte Carlo 
%   simulation and the latter is computed once with respect to the true 
%   reference states and measurements.
%
%   If multiple monte-carlo cases are specified using SETODTBXOPTIONS, 
%   this is capable of running the monte-carlo cases in parallel.  Simply
%   open a pool of parallel workers using 'matlabpool' and estseq will
%   utilize them.  The only contraints placed on the caller when running
%   monte-carlo cases in parallel are:
%    1. the dynfun and datafun functions must not retain state that later 
%       monte-carlo runs will rely on
%    2. any Java classes used must be serializable
%    3. any variables that are used in the dynfun or datafun functions but
%       are setup before the call to estseq must appear somehwhere in the 
%       setup code (e.g. setting up a variable by loading it from a file 
%       will assign it a value without the variable name ever appearing in 
%       the code - this will cause an error in parallel execution)
%
%   Example
%      Given xdot = pr2bp(t,x,mu), [y,H,R] = range2d(t,x,sig):
%         estseq(@pr2bp,@range2d,tspan,x0,P0,[],mu,sig)
%         [t,x,P] = estseq(@pr2bp,@range2d,tspan,x0,P0,[],mu,sig)
%         estsol = estseq(@pr2bp,@range2d,tspan,x0,P0,[],mu,sig)
%      With opts = setOdtbxOptions('OdeSolver',@ode45,...):
%         estseq(@pr2bp,@range2d,tspan,x0,P0,opts,mu,sig)
%
%   keyword: Estimation,
%
%   See also
%      options handling:      ODTBXOPTIONS, SETODTBXOPTIONS,
%                             GETODTBXOPTIONS
%      evaluating solutions:  ESTVAL
%      other ODEAS filters:   ESTBAT
%      other ODEAS utilties:  INTEG, OBSERV
%      ODE solvers:           ODE113, ODE23, ODE45
%      covariance storage:    SCRUNCH, UNSCRUNCH

% OD Toolbox Increment 7

% Russell Carpenter
% NASA Goddard Space Flight Center

% NOTE: The interface design of this function is based on ODE45.M, which
% is copyrighted by The MathWorks, Inc.

% Modification History
% ---------------------
% 2009/01/13 Sun Hur-Diaz   Added an option to use the Schmidt-Kalman
%                           filter
% 2009/06/30 Sun Hur-Diaz   Pre-allocated additional matrices to improve 
%                           speed and remove sidebar warnings
% 2009/09/14 Sun Hur-Diaz   Corrected the initialization of the estimator
%                           states in the Monte Carlo simulation
% 2009/09/25 Sun Hur-Diaz   Save measurement innovations covariance(s)  
%                           for post-processing
% 2009/10/13 Sun Hur-Diaz   Added a check for NaN in measurements and set
%                           the corresponding elements of K to zero in the
%                           covariance analysis section of the code
% 2009/10/29 Kevin Berry    Added a check for NaN measurements to the
%                           inputs to kalmup
% 2010/02/23 Sun Hur-Diaz   Set isel to all measurements for general
%                           vectorized measurement update
% 2010/02/24 John Gaebler   Edited help section. Removed warnings 
%                           (mostly replaced junk output with '~'). 
%                           Added ominusc to measurement call allowing 
%                           numerical computation of H.
% 2013/02/06 Phillip Anderson   Converted to Object Oriented class

    properties
        
    end
    
    methods
        function obj = estseq(varargin)
            %% Input Parsing and Setup
            % Parse the input list and options structure.  Pre-allocate arrays, using a
            % cell index for the monte carlo cases, which will avoid the need for each
            % case to have time series at common sample times.  Use an extra dimension
            % "on the right" within each monte carlo case to accomodate the time
            % series, which will avoid the need for conversions from cell to double for
            % plotting.  Where it makes sense, use cell indices to partition
            % large matrices into submatrices, to avoid the need for opaque indexing
            % computations.
            %
            % This should be a subfunction, or if there is a lot of commonality with
            % estseq's version, a private function.
            %
            % If there are no input arguments, perform a built-in self-test.  If there
            % are no output arguments, then plot the results of the input self-test
            % number as a demo.

            if nargin >= 4,
                if all(isfield(varargin{1}, {'tru','est'})),
                    obj.dynfun = varargin{1};
                else
                    obj.dynfun.tru = varargin{1};
                    obj.dynfun.est = varargin{1};
                end
                if all(isfield(varargin{2}, {'tru','est'})),
                    obj.datfun = varargin{2};
                else
                    obj.datfun.tru = varargin{2};
                    obj.datfun.est = varargin{2};
                end
                
                obj.tspan = varargin{3};
                
                if isstruct(varargin{4}),
                    obj.Xo = varargin{4}.Xo;
                    obj.Xbaro = varargin{4}.Xbaro;
                else
                    obj.Xo = varargin{4};
                    obj.Xbaro = varargin{4};
                end
            end
            
            if nargin >= 5,
                if isstruct(varargin{5}),
                    obj.Po = varargin{5}.Po;
                    obj.Pbaro = varargin{5}.Pbaro;
                else
                    obj.Po = varargin{5};
                    obj.Pbaro = varargin{5};
                end
                if isempty(obj.Po)
                    obj.Po = 1/eps*eye(size(obj.Xo));
                end
                if isempty(obj.Pbaro)
                    obj.Pbaro = 1/eps*eye(size(obj.Xo));
                end
            elseif nargin >= 4,
                obj.Po = 1/eps*eye(size(obj.Xo));
                obj.Pbaro = obj.Po;
            end
            
            if nargin >=6,
                obj.options = varargin{6};
            else
                obj.options = setOdtbxOptions('OdeSolvOpts',odeset);
            end
            
            if nargin >= 7,
                if all(isfield(varargin{7}, {'tru','est'}))
                    obj.dynarg = varargin{7};
                else
                    obj.dynarg.tru = varargin{7};
                    obj.dynarg.est = varargin{7};
                end
            elseif nargin >= 4,
                obj.dynarg.tru = [];
                obj.dynarg.est = [];
            end
            
            if nargin >= 8,
                if all(isfield(varargin{8}, {'tru','est'}))
                    obj.datarg = varargin{8};
                else
                    obj.datarg.tru = varargin{8};
                    obj.datarg.est = varargin{8};
                end
            elseif nargin >= 4,
                obj.datarg.tru = [];
                obj.datarg.est = [];
            end
            
            % TODO: Need to make sure having 3-D C matrix won't mess up Schmidt-Kalman option
            if nargin >= 9,
                if isa(varargin{9},'function_handle'),
                    obj.mapfun = varargin{9}; %#ok<NASGU> %TODO
                elseif isa(varargin{9},'numeric') % constant solve-for map
                    obj.S = varargin{9};
                    obj.C = []; %zeros(0,0,length(tspan)); % in case C is not input, solve for all states
                end
            elseif nargin >= 4, % If S & C not input, solve for all states
                obj.S = eye(size(obj.Po));
                obj.C = []; %zeros(0,0,length(tspan));
            end
            if nargin >= 10, % constant consider map
                obj.C = varargin{10}; %repmat(varargin{10},[1,1,length(tspan)]);
            end
        end
        
        function varargout = run_estimator(obj)
            %% ESTSEQ: Sequential Estimator
            %
            % ESTSEQ is the primary sequential estimator for OD Toolbox.  The original
            % version was a fairly slow Kalman estimator of the sort described Tapley,
            % Schutz, and Born, and other standard textbooks.  The current version is a
            % fairly significant generalization, based primarily on the work of
            % Markley, et al. (F. L. Markley, E. Seidewitz, and M. Nicholson, "A
            % General Model for Attitude Determination Error Analysis,"  _NASA
            % Conference Publication 3011: Flight Mechanics/Estimation Theory
            % Symposium_, May 1988, pp. 3-25, and F. L. Markley, E. Seidewitz, and J.
            % Deutschmann, "Attitude Determination Error Analysis: General Model and
            % Specific Application,"  _Proceedings of the CNES Space Dynamics
            % Conference_, Toulouse, France, November 1989, pp. 251-266).
            %
            % The following mathematical specifications were published from comments
            % embedded within the m-file.
            
            ncases = getOdtbxOptions(obj.options,'MonteCarloCases',1);
            niter = getOdtbxOptions(obj.options,'UpdateIterations',1); % Default is 1
            refint = getOdtbxOptions(obj.options,'refint',3);
            ischmidt = getOdtbxOptions(obj.options,'SchmidtKalman',0);

            % Acquire the UpdateVectorized flag and store it. The default value is 1,
            % which means to process measurments together in a vector.
            upvec = getOdtbxOptions(obj.options, 'UpdateVectorized', 1);


            %% Time tag arrays
            % Compute a vector of time tags that account for updates (and possible
            % iterations) at each measurement time.

            % integrator outputs between meas. updates
            tint = refine(obj.tspan,refint);
            lenti = length(tint);

            % indices within tint that point back to tspan, i.e., tint(ispan)=tspan
            ispan = 1:(refint+1):lenti;

            % accounts for updates/iterations
            titer = [reshape([repmat(tint(ispan(1:end-1)),niter+1,1);...
                reshape(tint(~ismember(tint,tspan)),refint,[])],[],1);...
                repmat(tint(ispan(end)),niter+1,1)]';
            lentr = length(titer);

            % Find indices within titer that point back to tint
            [~,iint] = ismember(tint,titer); clear junk 

            %% Solve-For and Consider Mapping
            %
            % The mapping of the state-space into solve-for and consider subspaces is
            % defined according to
            %
            % $$ s(t) = S(t) x(t), \quad c(t) = C(t) x(t) $$
            %
            % $$ M(t) = \Bigl[ S(t);\, C(t) \Bigr], \quad
            % M^{-1}(t) = \Bigl[ \tilde{S}(t),\, \tilde{C}(t) \Bigr]$$
            %
            % $$ x(t) = \tilde{S}(t) s(t) + \tilde{C}(t) c(t) $$

            if ~exist('mapfun','var'),
                ns = size(obj.S(:,:,1),1);
                nc = size(obj.C(:,:,1),1);
                if lentr > 1,
                    if size(obj.S,3) > 1 || size(obj.C,3) > 1,
                        disp('For time-varying S & C, ESTSEQ requires input of mapfun (currently not implemented).')
                        disp('Replicating S(:,:,1) & C(:,:,1) instead.')
                        obj.S = obj.S(:,:,1);
                        obj.C = obj.C(:,:,1);
                    end
                    obj.S = repmat(obj.S,[1,1,lentr]);
                    if isempty(obj.C),
                        obj.C = zeros(0,0,lentr);
                    else
                        obj.C = repmat(obj.C,[1,1,lentr]);
                    end
                end
            else % TODO: implement mapfun
                error('mapfun not implemented in this release')
            end
            n = ns + nc;
            Stilde=zeros(n,ns,lentr);
            Ctilde=zeros(n,nc,lentr);
            for i = lentr:-1:1,
                Minv = inv([S(:,:,i);C(:,:,i)]);
                Stilde(:,:,i) = Minv(:,1:ns); 
                Ctilde(:,:,i) = Minv(:,ns+1:n); 
            end

            %% Monte Carlo Simulation
            % Always perform at least one actual simulation as a check against
            % linearization problems.  Generate random deviations from the reference as
            % initial conditions for each monte carlo case.  Integrate each deviated
            % case, and use this as truth for measurement simulation and estimation
            % error generation.  Do this after plotting the covariance results, so the
            % user can terminate the run if obvious problems occur, since the
            % simulation may be slow, especially if a lot of monte carlo cases are
            % running.

            % Pre-allocate arrays that need to be filled in forward-time order (the
            % rest can be fully allocated when created).
            lents = length(tspan);

            m = 14;

            [obj.t,obj.X,obj.Xhat,obj.Phat,obj.y,obj.Y,obj.e,~,~,obj.eflag,obj.Pdy] = deal(cell(1,ncases));
            [obj.X{:}] = deal(NaN(n,lenti));
            [obj.Xhat{:}] = deal(NaN(length(obj.Xbaro),lentr));
            [obj.Phat{:}] = deal(NaN([size(obj.Pbaro),lentr]));
            [obj.y{:}] = deal(NaN(m,lentr));     % Measurement innovations
            [obj.eflag{:}] = deal(NaN(m,lentr));
            [obj.Y{:}] = deal(NaN(m,lents));     % True measurements
            [obj.Pdy{:}] = deal(NaN(m,m,lentr)); % Measurement innovations covariance

            % Pre-allocate arrays for consider covariance analysis
            % True (total) covariance
            obj.Pa    = NaN([n,n,lentr]);       % a-priori
            obj.Pv    = NaN(size(Pa));          % measurement noise
            obj.Pw    = NaN(size(Pa));          % process noise
            obj.Pm    = NaN(size(Pa));
            obj.P     = NaN(size(Pa));          % total
            obj.Pdyt  = NaN(m,m,lentr);         % measurement innovations
            % Assumed covariance of solved for states only if ischmidt=0 otherwise
            % it is of all the states
            obj.Phata = NaN([size(obj.Pbaro),lentr]);
            obj.Phatv = NaN(size(obj.Phata));
            obj.Phatw = NaN(size(obj.Phata));
            obj.Phatm = NaN(size(obj.Phata));
            obj.Phatt = NaN(size(obj.Phata));
            % Covariance error of solved for states only
            dPa   = NaN([ns,ns,lentr]);
            dPv   = NaN(size(dPa));
            dPw   = NaN(size(dPa));
            dPm   = NaN(size(dPa));
            % Sensitivity matrix of all states to a-priori
            Sig_a = NaN(size(obj.Pa));

            Href = NaN(m,size(obj.P,2),lentr);
            Hsref = NaN(m,size(obj.Pbaro,2),lentr);
            Rhat = NaN(m,m,lentr);
            R = NaN(m,m,lents);

            % Acquire the Monte Carlo Seed for the random number generator
            % if the user has specified it.
            monteseed     = getOdtbxOptions(obj.options, 'MonteCarloSeed', NaN);
            monteseed_use = NaN(1,ncases); % Pre-allocate array

            if(~isnan(monteseed))

                if((length(monteseed) ~= ncases) && (length(monteseed) ~= 1))

                    error('Number of Monte Carlo Seeds specified does not match the number of cases.');

                elseif((ncases > 1) && (length(monteseed) == 1))

                    for bb=1:ncases

                        monteseed_use(bb) = monteseed + (bb-1);

                    end

                else

                    monteseed_use = monteseed;

                end

            else

                for bb=1:ncases

                    monteseed_use(bb) = monteseed;

                end

            end

            eratio = getOdtbxOptions(obj.options, 'EditRatio', []); % Default is empty, meaning no meas. editing
            eflag_set  = getOdtbxOptions(obj.options, 'EditFlag', []); % Default is empty (no meas. editing)

            % Run Kalman Filter on the measurements generated above
            for j = 1:ncases,

                obj.Xhat{j}(:,1) = obj.Xbaro;    % The filter i.c. is always the same

                obj.Phat{j}(:,:,1) = obj.Pbaro;

                for i = 1:lents,

                    % Time update
                    if i == 1,
                        thisint = 1;

                        obj.X{j}(:,1) = obj.Xo + covsmpl(obj.Po, 1, monteseed_use(j));

                        if j == 1
                            % True covariance
                            obj.Pa(:,:,1) = obj.Po;
                            obj.Pv(:,:,1) = zeros(size(obj.Po));
                            obj.Pw(:,:,1) = zeros(size(obj.Po));
                            obj.Pm(:,:,1) = zeros(size(obj.Po));
                            obj.P(:,:,1) = obj.Pa(:,:,1);
                            % Assumed covariance
                            obj.Phata(:,:,1) = obj.Pbaro;
                            obj.Phatv(:,:,1) = zeros(size(obj.Pbaro));
                            obj.Phatw(:,:,1) = zeros(size(obj.Pbaro));
                            obj.Phatm(:,:,1) = zeros(size(obj.Pbaro));
                            Sig_a(:,:,1) = [Stilde(:,:,1), Ctilde(:,:,1)];
                        end

                    else
                        %% Combine into one big estimator for a combined state

                        thisint = iint(ispan(i-1)):iint(ispan(i))-niter;
                        BigX = [obj.Xhat{j}(:,thisint(1)); obj.X{j}(:,i-1)];
                        wrapper = @obj.wrapperdyn;
                        [~,xdum,phidum,sdum] = integ(wrapper,titer(thisint),BigX,[],obj.dynarg)
                        
%                         thisint = iint(ispan(i-1)):iint(ispan(i))-niter;
%                         [~,xdum,phidum,sdum] = integ(dynfun.est,titer(thisint),Xhat{j}(:,thisint(1)),[],dynarg.est);
%                         if length(thisint) == 2 % This is because for time vector of length 2, ode outputs >2
%                             xdum = [xdum(:,1) xdum(:,end)];
%                             phidum(:,:,2) = phidum(:,:,end);
%                             sdum(:,:,2) = sdum(:,:,end);
%                         end
%                         Xhat{j}(:,thisint) = xdum;
%                         for k = 2:length(thisint)
%                             sdum(:,:,k) = (sdum(:,:,k) + sdum(:,:,k)')/2;
%                             Phat{j}(:,:,thisint(k)) = phidum(:,:,k)*Phat{j}(:,:,thisint(1))*phidum(:,:,k)' + sdum(:,:,k);
%                             Phat{j}(:,:,thisint(k)) = (Phat{j}(:,:,thisint(k)) + Phat{j}(:,:,thisint(k))')/2;
%                         end
% 
%                         [~,xdum,~,sdum] = integ(dynfun.tru,tint(i-1:i),X{j}(:,i-1),[],dynarg.tru);
%                         X{j}(:,i) = xdum(:,end);%+covsmpl(sdum(:,:,end));

                        % Replace with one big integrator for a combined state

                       %%

                        if j == 1
                            % True covariance
                            [obj.Pw(:,:,thisint(2:end)),~,Phi] = covprop(obj.dynfun.tru,...
                                titer(thisint),obj.Pw(:,:,thisint(1)),...
                                obj.X{1}(:,ispan(i-1):ispan(i)),obj.options,obj.dynarg.tru);
                            for k = 1:length(thisint)-1,
                                obj.Pa(:,:,thisint(k+1)) = Phi(:,:,k)*obj.Pa(:,:,thisint(k))*Phi(:,:,k)';
                                obj.Pv(:,:,thisint(k+1)) = Phi(:,:,k)*obj.Pv(:,:,thisint(k))*Phi(:,:,k)';
                                obj.Pm(:,:,thisint(k+1)) = Phi(:,:,k)*obj.Pm(:,:,thisint(k))*Phi(:,:,k)';
                                Sig_a(:,:,thisint(k+1)) = Phi(:,:,k)*Sig_a(:,:,thisint(k));
                            end

                            % Assumed covariance
                            % If ischmidt=1, the Phiss corresponds to the full state transition
                            % matrix, and not just the solved-for states.  Similarly for Qdhat.
                            [obj.Phatw(:,:,thisint(2:end)),~,Phiss] = covprop(obj.dynfun.est,...
                                titer(thisint),obj.Phatw(:,:,thisint(1)),...
                                obj.Xhat{1}(:,ispan(i-1):ispan(i)),obj.options,obj.dynarg.est);
                            for k = 1:length(thisint)-1,
                                obj.Phata(:,:,thisint(k+1)) = ...
                                    Phiss(:,:,k)*obj.Phata(:,:,thisint(k))*Phiss(:,:,k)';
                                obj.Phatv(:,:,thisint(k+1)) = ...
                                    Phiss(:,:,k)*obj.Phatv(:,:,thisint(k))*Phiss(:,:,k)';
                                obj.Phatm(:,:,thisint(k+1)) = ...
                                    Phiss(:,:,k)*obj.Phatm(:,:,thisint(k))*Phiss(:,:,k)';
                            end
                        end
                    end

                    %% Burn
                    for k = 1:length(obj.dynarg.est.targetBurn)
                        if tint(i) == obj.dynarg.est.targetBurn(k)
                            v1 = obj.Xhat{j}(10:12,thisint(end));

                            v1 = fminunc(@(v) findTargetBurn(v,[tint(i) tint(end)],...
                                obj.Xhat{j}(:,thisint(end)),dynarg.tru),v1);

                            dv = v1-obj.Xhat{j}(10:12,thisint(end));

                            disp('Target Burn...')
                            disp(dv)

                            obj.Xhat{j}(10:12,thisint(end)) = v1;

                            dt = obj.dynarg.tru.mass/obj.dynarg.tru.thrust*norm(dv);
                            err = obj.dynarg.tru.exError*norm(dv);
                            if err > 1e-6
                                err = 1e-6;
                            end

                            q = (err/dt)^2;

                            I = eye(3,3);

                            Qman(7:12,7:12) = q*[I*dt^3/3 I*dt^3/3;...
                                                 I*dt^2/2 I*dt];

                            xerr = covsmpl(Qman);

                            obj.X{j}(7:12,i) = obj.X{j}(7:12,i)+[zeros(3,1);dv] + xerr(7:12,1);

            %                 v1 = fminunc(@(v) findTargetBurn(v,[tint(i) tint(end)],...
            %                     X{j}(:,i),dynarg.tru),v1);
            %                 
            %                 X{j}(10:12,i) = v1;

                            disp('Execution Error')
                            disp(xerr(7:9,1))

                            obj.Phat{j}(:,:,thisint(end)) = obj.Phat{j}(:,:,thisint(end))...
                                + Qman;

                            if j == 1
                                obj.Pm(1:12,1:12,thisint(end)) = obj.Pm(1:12,1:12,thisint(end)) + Qman;
                                obj.Phatm(1:12,1:12,thisint(end)) = obj.Phatm(:,:,thisint(end)) + Qman;
                            end
                        end
                    end

                    if j == 1
                        % Covariance differences and formal covariance over prop interval
                        for k = thisint,
                            if ischmidt == 1 % Both the true and assumed are the same size
                                dPa(:,:,k) = obj.S(:,:,k)*(obj.Pa(:,:,k) - obj.Phata(:,:,j))*obj.S(:,:,j)';
                                dPv(:,:,k) = obj.S(:,:,k)*(obj.Pv(:,:,k) - obj.Phatv(:,:,j))*obj.S(:,:,j)';
                                dPw(:,:,k) = obj.S(:,:,k)*(obj.Pw(:,:,k) - obj.Phatw(:,:,j))*obj.S(:,:,j)';
                                dPm(:,:,k) = obj.S(:,:,k)*(obj.Pm(:,:,k) - obj.Phatm(:,:,j))*obj.S(:,:,j)';
                            else
                                dPa(:,:,k) = obj.S(:,:,k)*obj.Pa(:,:,k)*obj.S(:,:,k)' - obj.Phata(:,:,k);
                                dPv(:,:,k) = obj.S(:,:,k)*obj.Pv(:,:,k)*obj.S(:,:,k)' - obj.Phatv(:,:,k);
                                dPw(:,:,k) = obj.S(:,:,k)*obj.Pw(:,:,k)*obj.S(:,:,k)' - obj.Phatw(:,:,k);
                                dPm(:,:,k) = obj.S(:,:,k)*obj.Pm(:,:,k)*obj.S(:,:,k)' - obj.Phatm(:,:,k);
                            end
                            obj.Phatt(:,:,k) = obj.Phata(:,:,k) + obj.Phatv(:,:,k) + obj.Phatw(:,:,k)+ obj.Phatm(:,:,k);
                            obj.P(:,:,k) = obj.Pa(:,:,k) + obj.Pv(:,:,k) + obj.Pw(:,:,k)+ obj.Pm(:,:,k);
                        end
                    end

                    nmeas = size(obj.Y{1}(:,1));
                    isel = 1:nmeas;

                    obj.Y{j}(:,i) = feval(obj.datfun.tru,tspan(i),obj.X{j}(:,i),obj.datarg.tru);
                    [~,Href(:,:,i),R(:,:,i)] = ominusc(obj.datfun.tru,tspan(i),obj.X{1}(:,i),obj.Y{j}(:,i),obj.options,[],obj.datarg.tru);
                    obj.Y{j}(:,i) = obj.Y{j}(:,i) + covsmpl(R(:,:,i)); 

                    % Do meas update niter times
                    for k = (thisint(end)+1):iint(ispan(i)), 

                        if(upvec == 1)

                            if ischmidt == 1
                                [obj.Xhat{j}(:,k),obj.Phat{j}(:,:,k),obj.eflag{j}(isel,k),obj.y{j}(isel,k),obj.Pdy{j}(isel,isel,k),~] = kalmup(obj.datfun.est,...
                                    obj.tspan(i),obj.Xhat{j}(:,k-1),obj.Phat{j}(:,:,k-1),obj.Y{j}(:,i),...
                                    obj.options,eflag_set,eratio,obj.datarg.est,isel,obj.S(:,:,i),obj.C(:,:,i)); 
                            else
                                [obj.Xhat{j}(:,k),obj.Phat{j}(:,:,k),obj.eflag{j}(isel,k),obj.y{j}(isel,k),obj.Pdy{j}(isel,isel,k),~] = kalmup(obj.datfun.est,...
                                    obj.tspan(i),obj.Xhat{j}(:,k-1),obj.Phat{j}(:,:,k-1),obj.Y{j}(:,i),...
                                    obj.options,eflag_set,eratio,obj.datarg.est,isel); 
                            end

                        else

                            Xhat_tmp = obj.Xhat{j}(:,k-1);

                            Phat_tmp = obj.Phat{j}(:,:,k-1);

                            % This assumes that there are always the same number of measurements for
                            % all cases for all time.
                            for bb=1:nmeas

                                if ischmidt == 1
                                    [Xhat_tmp,Phat_tmp,obj.eflag{j}(bb,k),obj.y{j}(bb,k),obj.Pdy{j}(bb,bb,k),~] = kalmup(obj.datfun.est,...
                                        obj.tspan(i),Xhat_tmp,Phat_tmp,obj.Y{j}(:,i),...
                                        obj.options,eflag_set,eratio,obj.datarg.est,bb,obj.S(:,:,i),obj.C(:,:,i));
                                else
                                    [Xhat_tmp,Phat_tmp,obj.eflag{j}(bb,k),obj.y{j}(bb,k),obj.Pdy{j}(bb,bb,k),~] = kalmup(obj.datfun.est,...
                                        obj.tspan(i),Xhat_tmp,Phat_tmp,obj.Y{j}(:,i),...
                                        obj.options,eflag_set,eratio,obj.datarg.est,bb);
                                end

                            end

                            obj.Xhat{j}(:,k) = Xhat_tmp;

                            obj.Phat{j}(:,:,k) = Phat_tmp;

                        end

                    end

                    if j == 1

                        k = thisint(end)+1;

                        Ybar = feval(obj.datfun.est,obj.tspan(i),obj.Xhat{1}(:,k-1),obj.datarg.est);
                        [~,Hsref(:,:,i),Rhat(:,:,i)] = ominusc(obj.datfun.est,obj.tspan(i),obj.Xhat{1}(:,k-1),Ybar,obj.options,[],obj.datarg.est);

                        obj.Pdyt(:,:,k-1) = (Href(:,:,i)*obj.P(:,:,k-1)*Href(:,:,i)' + R(:,:,i));

                        inan = isnan(obj.Y{1}(:,i)) | isnan(Ybar);
                        Hsrefm = Hsref(~inan,:,i);
                        Hrefm = Href(~inan,:,i);
                        Rhatm = Rhat(~inan,~inan,i);
                        Rm = R(~inan,~inan,i);

                        obj.Pdyt(:,:,k-1) = NaN(size(R(:,:,i)));
                        Pdytm = (Hrefm*P(:,:,k-1)*Hrefm' + Rm);

                        obj.Pdyt(~inan,~inan,k-1) = Pdytm;

                        % Compute the gains
                        K = Phatt(:,:,k-1)*Hsrefm'/...
                            (Hsrefm*Phatt(:,:,k-1)*Hsrefm' + Rhatm);

                        if ischmidt == 1

                            % We apply the gains only to the solve-for
                            K = obj.S(:,:,i)*K;

                            % Calling kalmup may have extra overhead but could allow it for
                            % iterative Kalman filter - need to flesh this out
                            %         [xtmp,Ptmp,efltmp,dytmp,Pdytemp,K] = kalmup(datfun.est,...
                            %             tspan(i),Xsref(:,i),Phat(:,:,k-1),Ybar(:,i),options,[],...
                            %             [],datarg.est,[],S(:,:,i),C(:,:,i))

                            % Update the total asssumed covariance
                            ImSKH = eye(ns+nc) - Stilde(:,:,k-1)*K*Hsrefm;
                            obj.Phata(:,:,k) = ImSKH*obj.Phata(:,:,k-1)*ImSKH';
                            obj.Phatv(:,:,k) = ImSKH*obj.Phatv(:,:,k-1)*ImSKH' + ...
                                Stilde(:,:,k-1)*K*Rhatm*K'*Stilde(:,:,k-1)';
                            obj.Phatw(:,:,k) = ImSKH*obj.Phatw(:,:,k-1)*ImSKH';
                            obj.Phatm(:,:,k) = ImSKH*obj.Phatm(:,:,k-1)*ImSKH';

                        else

                            % Update the asssumed covariance
                            ImKH = eye(ns) - K*Hsrefm;
                            obj.Phata(:,:,k) = ImKH*obj.Phata(:,:,k-1)*ImKH';
                            obj.Phatv(:,:,k) = ImKH*obj.Phatv(:,:,k-1)*ImKH' + K*Rhatm*K';
                            obj.Phatw(:,:,k) = ImKH*obj.Phatw(:,:,k-1)*ImKH';
                            obj.Phatm(:,:,k) = ImKH*obj.Phatm(:,:,k-1)*ImKH';

                        end

                        % Update the true covariance. Assign measurement noise only to
                        % measurement noise partitions of the total covariance
                        ImSKH = eye(ns+nc) - Stilde(:,:,k-1)*K*Hrefm;
                        obj.Pa(:,:,k) = ImSKH*obj.Pa(:,:,k-1)*ImSKH';
                        obj.Pv(:,:,k) = ImSKH*obj.Pv(:,:,k-1)*ImSKH' ...
                            + Stilde(:,:,k-1)*K*Rm*K'*Stilde(:,:,k-1)';
                        obj.Pw(:,:,k) = ImSKH*obj.Pw(:,:,k-1)*ImSKH';
                        obj.Pm(:,:,k) = ImSKH*obj.Pm(:,:,k-1)*ImSKH';
                        obj.P(:,:,k) = obj.Pa(:,:,k) + obj.Pv(:,:,k) + obj.Pw(:,:,k)+ obj.Pm(:,:,k);

                        % Update the sensitivity matrix to apriori
                        Sig_a(:,:,k) = ImSKH*Sig_a(:,:,k-1);

                        if ischmidt == 1

                            % Post-update covariance differences and formal covariance
                            dPa(:,:,k) = obj.S(:,:,j)*(obj.Pa(:,:,k) - obj.Phata(:,:,k))*obj.S(:,:,j)';
                            dPv(:,:,k) = obj.S(:,:,j)*(obj.Pv(:,:,k) - obj.Phatv(:,:,k))*obj.S(:,:,j)';
                            dPw(:,:,k) = obj.S(:,:,j)*(obj.Pw(:,:,k) - obj.Phatw(:,:,k))*obj.S(:,:,j)';
                            dPw(:,:,m) = obj.S(:,:,j)*(obj.Pm(:,:,k) - obj.Phatm(:,:,k))*obj.S(:,:,j)';

                        else

                            % Post-update covariance differences and formal covariance
                            dPa(:,:,k) = obj.S(:,:,k)*obj.Pa(:,:,k)*obj.S(:,:,k)' - obj.Phata(:,:,k);
                            dPv(:,:,k) = obj.S(:,:,k)*obj.Pv(:,:,k)*obj.S(:,:,k)' - obj.Phatv(:,:,k);
                            dPw(:,:,k) = obj.S(:,:,k)*obj.Pw(:,:,k)*obj.S(:,:,k)' - obj.Phatw(:,:,k);
                            dPm(:,:,k) = obj.S(:,:,k)*obj.Pm(:,:,k)*obj.S(:,:,k)' - obj.Phatm(:,:,k);

                        end

                        obj.Phatt(:,:,k) = obj.Phata(:,:,k) + obj.Phatv(:,:,k) + obj.Phatw(:,:,k) + obj.Phatm(:,:,k);

                        % Now copy the data if necessary to fill in for any iterations below.
                        % Zero-order hold
                        for z = (k+1):iint(ispan(i)),
                            obj.Pa(:,:,z) = obj.Pa(:,:,k);
                            obj.Pv(:,:,z) = obj.Pv(:,:,k);
                            obj.Pw(:,:,z) = obj.Pw(:,:,k);
                            obj.Pm(:,:,z) = obj.Pm(:,:,k);
                            obj.Phata(:,:,z) = obj.Phata(:,:,k);
                            obj.Phatv(:,:,z) = obj.Phatv(:,:,k);
                            obj.Phatw(:,:,z) = obj.Phatw(:,:,k);
                            obj.Phatm(:,:,z) = obj.Phatm(:,:,k);
                            dPa(:,:,z) = dPa(:,:,k);
                            dPv(:,:,z) = dPv(:,:,k);
                            dPw(:,:,z) = dPw(:,:,k);
                            dPm(:,:,z) = dPm(:,:,k);
                            obj.Phatt(:,:,z) = obj.Phatt(:,:,k);
                            obj.P(:,:,z) = obj.P(:,:,k);
                            Sig_a(:,:,z) = Sig_a(:,:,k);
                        end

                    end

                end

            end

            %% Estimation Error Ensemble
            % Generate the time series of estimation errors for each
            % case.  Use estval to plot these data if no output arguments are supplied.

            if ischmidt==1
                [obj.e{:}] = deal(NaN(n,lenti));
            else
                [obj.e{:}] = deal(NaN(ns,lenti));
            end
            for j = ncases:-1:1,
                obj.t{j} = titer;
                obj.Phat{j} = scrunch(obj.Phat{j}); % Need to look at solve for only
                for i = lenti:-1:1,
                    % This misses any update iterations
                    if ischmidt == 1
                        obj.e{j}(:,iint(i)) = obj.Xhat{j}(:,iint(i)) - obj.X{j}(:,i); 
                    else
                        obj.e{j}(:,iint(i)) = obj.Xhat{j}(:,iint(i)) - obj.S(:,:,iint(i))*obj.X{j}(:,i); 
                    end
                    % Fill in iterations if required
                    if i == 1,
                        thisint = 2:iint(i)-1;
                    else
                        thisint = iint(i-1)+1:iint(i)-1;
                    end
                    for k = thisint,
                        if ischmidt == 1
                            obj.e{j}(:,k) = obj.Xhat{j}(:,k) - obj.X{j}(:,i); 
                        else
                            obj.e{j}(:,k) = obj.Xhat{j}(:,k) - obj.S(:,:,k)*obj.X{j}(:,i); 
                        end
                    end
                end
            end

            %% Sensitivity Mosaics
            % Generate "sensitivity mosaics," which are checkerboard plots of the
            % sensitivity matrices.  For some reason, Matlab's pcolor function does not
            % plot the final row and column, so append an extra row and column to get
            % the correct plot.  Initially plot the sensitivity at the final time,
            % and put up a slider that lets the user scan through sensitivities over
            % the time span.

            % First map the full sensitivities to the solve-for state space:
            obj.Sig_sa = NaN(ns,n,lentr);
            for j = lentr:-1:1,
                obj.Sig_sa(:,:,j) = obj.S(:,:,j)*Sig_a(:,:,j); 
            end

            
            %% Output results
            if nargout >= 3,
                varargout{1} = obj.t;
                varargout{2} = obj.Xhat;
                varargout{3} = obj.Phat;
            end
            if nargout >= 4,
                varargout{4} = obj.e;
            end
            if nargout >= 5,
                varargout{5} = obj.y;
            end
            if nargout >= 6,
                varargout{6} = obj.Pa;
                varargout{7} = obj.Pv;
                varargout{8} = obj.Pw;
                varargout{9} = obj.Phata;
                varargout{10} = obj.Phatv;
                varargout{11} = obj.Phatw;
            end
            if nargout >= 12,
                varargout{12} = obj.Sig_sa;
            end
            if(nargout >= 13)
                varargout{13} = obj.eflag;
            end
            if nargout >= 14,
                varargout{14} = obj.Pdy;
            end
            if nargout >= 15,
                varargout{15} = obj.Pdyt;
            end
            if nargout >= 16
                varargout{16} = obj.Pm;
                varargout{17} = obj.Phatm;
            end

        end % run_estimator Function
        
        
        function [xdot,A,Q] = wrapperdyn(obj,t,X,opts)

            [xdot1,A1,Q1] = feval(obj.dynfun.est,t,X(1:6),opts.est);
            [xdot2,A2,Q2] = feval(obj.dynfun.tru,t,X(7:12),opts.tru);

            xdot = [xdot1;xdot2];
            A = blkdiag(A1,A2);
            Q = blkdiag(Q1,Q2);

        end
        
    end % Methods
end % Class
