function varargout = estsrif(varargin)
% ESTSRIF  Square-Root Information Filter (SRIF)
%
%   [T,X,P] = ESTSRIF(DYNFUN,DATFUN,TSPAN,X0,P0) with TSPAN = [T0 TFINAL]
%   integrates the system of differential equations x' = f(t,x) from T0 to
%   TFINAL with initial conditions X0.  A measurement update is first 
%   performed at T0 with the measurement generated by y = h(t,x) + v.  
%   Then a time update is performed.  At TFINAL, another measurement 
%   update is performed.  To obtain updates at multiple times 
%   T1, T2, ..., TFINAL, use TSPAN = [T0 T1 T2 ... TFINAL].
%
%   Function [F,A,Q]=DYNFUN(T,X,options) must return a column vector 
%   corresponding to f(t,x). If DYNFUN is "vectorized," then f(t,x) must be
%   a 2-D array with each column corresponding to f(t(i),x(t(i)). Function 
%   DYNFUN(T,X) must return an additional output if called with two output
%   arguments, which may either be a matrix corresponding to A(t), or else 
%   an empty matrix, in which case INTEG will numerically compute A(t) with
%   NUMJAC. If A(t) is supplied, it must be a 3-D array for the vectorized
%   case, with each "slice" corresponding to A(t(i)).  To include process
%   noise, DYNFUN must return the process noise spectral density matrix, Q
%   = E[ww'], where x' = f(t,x) + w, as an additional output.  If DYNFUN is
%   vectorized, then Q must be a 3-D array, with each "slice" corresponding
%   to Q(t(i)).
%
%   Function [h,H,R]=DATFUN(T,X,options) must return a column vector 
%   corresponding to h(t,x), and two additional outputs corresponding to 
%   the measurement partials, H(t) = dh(t,x)/dx, and the measurement noise 
%   covariance, R = E[vv'], where y = h(t,x) + v.  As an alternate to 
%   supplying H(t), DATFUN may return an empty matrix as its second output, 
%   in which case ESTINV will numerically compute H(t) using NUMJAC. If 
%   DATFUN is "vectorized," then h(t,x) must return as its first output a 
%   2-D array with each column corresponding to h(t(i),x(t(i)); its next 
%   two outputs must be 3-D arrays with each "slice" corresponding to 
%   H(t(i)) and R(t(i)), respectively.
%
%   The rows in the solution array X correspond to times returned in the 
%   column vector T, which are chosen by the integrator.  The rows in the 
%   solution covariance array P correspond to the unique lower triangular 
%   elements of P at the times T, appended by row from column 1 to the main 
%   diagonal.  The Ith row may be reformed into a matrix using 
%   UNSCRUNCH(P(I,:)).
%
%   [T,X,P] = ESTSRIF(DYNFUN,DATFUN,TSPAN,X0), where P0 is not specified, 
%   uses the default initial covariance corresponding to a diagonal matrix 
%   of 1/eps.  
%
%   [T,X,P] = ESTSRIF(DYNFUN,DATFUN,TSPAN,X0,P0,OPTIONS) performs as above
%   with default properties replaced by values in OPTIONS, an argument
%   created with the SETODTBXOPTIONS function.  See ODTBXOPTIONS for
%   details. Commonly used options allow one to specify parameters or
%   features of the estimator, force model, and measurment model.  
%
%   [T,X,P] = ESTSRIF(DYNFUN,DATFUN,TSPAN,X0,P0,OPTIONS,DYNARG,DATARG)
%   passes DYNARG to DYNFUN and DATARG to DATFUN as DYNFUN(T,X,DYNARG) and
%   DATFUN(T,X,DATARG), respectively.  Use OPTIONS = [] as a place holder
%   if no options are set.
%
%   [T,X,P] = ESTSRIF(DYNFUN,DATFUN,TSPAN,X0,P0,OPTIONS,DYNARG,DATARG,S,C)
%   passes in solve-for and consider mapping matrices, S and C,
%   respectively.  These matrices partition the state into a solve-for
%   partition, S*x, and a consider partition, C*x.  Only parameters in the
%   former partition will be updated from the meaurements.  Use [] as a 
%   place holder for OPTIONS, DYNARG, and/or DATARG as necessary if these 
%   inputs are not required.  S and C can be 2-D or 3-D arrays.  If 3-D, 
%   the 3rd dimension corresponds to the time vector. However, time-
%   varying S and C are currently not implemented; therefore, constant S 
%   and C corresponding to the first time vector will be used.
%
%   To handle the different dimensions of the full state vs. the solve-
%   for and consider partitions, the user can either design DYNFUN and 
%   DATFUN to check for this, or specify DYNFUN and/or DATFUN as 
%   structures, whose fields are *.tru and *.est. The function specified 
%   in *.tru will be used to evaluate the full state, and the one in 
%   *.est will be used for the solve-for partition.  This is also a way 
%   to specify differences between the true and the estimator models of the
%   dynamics and the measurement data.  Similar conventions may be used 
%   for X0, P0, DYNARG, and DATARG, i.e. X0.Xo and X0.Xbaro, P0.Po and 
%   P0.Pbaro, DYNARG.tru and DYNARG.est, DATARG.tru and DATARG.est. 
%
%   [T,X,P,E] = ESTSRIF(DYNFUN,DATFUN,TSPAN,X0,P0,...) also returns the
%   estimation errors, E.
%
%   [T,X,P,E,DY,PA,PV,PW,PHATA,PHATV,PHATW] = ESTSRIF(...) returns the 
%   innovations, DY, and several addditional covariance matrices: PA, PV, 
%   and PW are the true covariances that arise only from the true  
%   _a priori_ covariance, the true measurement noise covariance, and the 
%   true process noise covariance, respectively;  PHATA, PHATV, PHATW are 
%   the estimator's covariances that arise only from the design values of 
%   the  _a priori_ covariance, the measurement noise covariance, and the 
%   process noise covariance.
%
%   [T,X,P,E,DY,PA,PV,PW,PHATA,PHATV,PHATW,SIGSA,EFLAG] = ESTSRIF(...) also
%   returns SIGSA, the sensitivity matrix of the solve-for states at each 
%   time step, as well as EFLAG, the array of edit flag values for all 
%   cases for all measurement types for all times. The edit flags may have 
%   the following values:
%
%       0   = Measurement was rejected (based on the edit ratio settings)
%       1   = Measurement was checked and passed the edit ratio test
%       2   = Measurement was forced to be accepted (based on edit flag
%             settings)
%
%   [T,X,P,E,DY,PA,PV,PW,PHATA,PHATV,PHATW,SIGSA,EFLAG,PDY,PDYT] = ESTSRIF(...) 
%   also returns the formal and the true covariance of the measurment 
%   innovations DY, where the former is computed from the Monte Carlo 
%   simulation and the latter is computed once with respect to the true 
%   reference states and measurements.
%
%   [T,X,P,E,DY,PA,PV,PW,PHATA,PHATV,PHATW,SIGSA,EFLAG,PDY,PDYT,XSTAR,PSTAR] = ESTSRIF(...)
%   also returns the smoothed state estimate XSTAR and covariance PSTAR in
%   the same format as the filter results if the smoother option is turned on.
%
%   [T,X,P,E, ... ,XSTAR,PSTAR,ESTAR] = ESTSRIF(...) also returns the
%   smoothed estimation errors, ESTAR.
%
%   [T,X,P,E, ... ,ESTAR,PM,PHATM] = ESTSRIF(...) also returns the true and 
%   formal covariance matrix partitions associated with external noise 
%   sources (ie maneuver execution error). External noise sources are added 
%   by modifying the RESTARTRECORD structure.
%
%   [T,X,P,E, ... ,ESTAR,PM,PHATM,RESTARTRECORD] = ESTSRIF(...) also 
%   returns a RESTARTRECORD structure that contains the necessary 
%   parameters to restart ESTSRIF at time TFINAL.  The RESTARTRECORD can be 
%   used to manipulate state, covariance, and filter parameters outside of 
%   ESTSRIF and continue analysis in a subsequent run.
%
%   If multiple monte-carlo cases are specified using SETODTBXOPTIONS,
%   this is capable of running the monte-carlo cases in parallel.  Simply
%   open a pool of parallel workers using 'matlabpool' and estsrif will
%   utilize them.  The only contraints placed on the caller when running
%   monte-carlo cases in parallel are:
%    1. the dynfun and datafun functions must not retain state that later 
%       monte-carlo runs will rely on
%    2. any Java classes used must be serializable
%    3. any variables that are used in the dynfun or datafun functions but
%       are setup before the call to estsrif must appear somehwhere in the 
%       setup code (e.g. setting up a variable by loading it from a file 
%       will assign it a value without the variable name ever appearing in 
%       the code - this will cause an error in parallel execution)
%
%   Example
%      Given xdot = pr2bp(t,x,mu), [y,H,R] = range2d(t,x,sig):
%         estsrif(@pr2bp,@range2d,tspan,x0,P0,[],mu,sig)
%         [t,x,P] = estsrif(@pr2bp,@range2d,tspan,x0,P0,[],mu,sig)
%         estsol = estsrif(@pr2bp,@range2d,tspan,x0,P0,[],mu,sig)
%      With opts = setOdtbxOptions('OdeSolver',@ode45,...):
%         estsrif(@pr2bp,@range2d,tspan,x0,P0,opts,mu,sig)
%
%   keyword: Estimation,
%
%   See also
%      options handling:      ODTBXOPTIONS, SETODTBXOPTIONS,
%                             GETODTBXOPTIONS
%      evaluating solutions:  ESTVAL
%      other ODEAS filters:   ESTBAT
%      other ODEAS utilties:  INTEG, OBSERV
%      ODE solvers:           ODE113, ODE23, ODE45
%      covariance storage:    SCRUNCH, UNSCRUNCH
%
% (This file is part of ODTBX, The Orbit Determination Toolbox, and is
%  distributed under the NASA Open Source Agreement.  See file source for
%  more details.)

% ODTBX: Orbit Determination Toolbox
% 
% Copyright (c) 2003-2011 United States Government as represented by the
% administrator of the National Aeronautics and Space Administration. All
% Other Rights Reserved.
% 
% This file is distributed "as is", without any warranty, as part of the
% ODTBX. ODTBX is free software; you can redistribute it and/or modify it
% under the terms of the NASA Open Source Agreement, version 1.3 or later.
% 
% You should have received a copy of the NASA Open Source Agreement along
% with this program (in a file named License.txt); if not, write to the 
% NASA Goddard Space Flight Center at opensource@gsfc.nasa.gov.

% NOTE: The interface design of this function is based on ODE45.M, which
% is copyrighted by The MathWorks, Inc.

% Modification History
% ---------------------
% Sun Hur-Diaz                   4/19/2010     Initial version based on 
% Emergent Space Technologies                  Rosemary Huang's prototype
%
% Rosemary Huang                 8/4/2010      Added smoother
% Goddard Space Flight Center
%
% Kenneth Getzandanner           8/10/2011     Implemented RESTARTRECORD 
% Goddard Space Flight Center                  functionality
%
% Ravi Mathur                    8/28/2012     Extracted regression test
% Emergent Space Technologies

%% ESTSRIF: Square-Root Information Filter Sequential Estimator
%
% This function first performs a linear covariance analysis based on 
% sequential Kalman filter formalism, identical to what's done in ESTSEQ.  
% Then the Monte Carlo simulation is performed.

%% Input Parsing and Setup
% Parse the input list and options structure.  Pre-allocate arrays, using a
% cell index for the monte carlo cases, which will avoid the need for each
% case to have time series at common sample times.  Use an extra dimension
% "on the right" within each monte carlo case to accomodate the time
% series, which will avoid the need for conversions from cell to double for
% plotting.  Where it makes sense, use cell indices to partition
% large matrices into submatrices, to avoid the need for opaque indexing
% computations.
%
% This should be a subfunction, or if there is a lot of commonality with
% estbat's version, a private function.
%
% The full self-test has been extracted to estsrif_test.m to conform to
% the new regression testing framework.
%
% If there are no output arguments, then plot the results of a particular
% input self-test as a demo.

if(nargin == 0)
    error('estsrif no longer supports zero-input regression testing. Please use estsrif_test.');
end

% testmode specifies which self test to run
if nargin == 1,
    testmode = varargin{1};
else
    testmode = false;
end

if nargin == 2
    restart = 1;
    restartRecord = varargin{1};
    Xmco = restartRecord.Xo;
    Xhatmco = restartRecord.Xhato;
    Xo = restartRecord.Xrefo;
    Xbaro = restartRecord.Xsrefo;
    Phatmco = restartRecord.Phato;
    Pao = restartRecord.Pao;
    Pvo = restartRecord.Pvo;
    Pwo = restartRecord.Pwo;
    Pmo = restartRecord.Pmo;
    Phatao = restartRecord.Phatao;
    Phatvo = restartRecord.Phatvo;
    Phatwo = restartRecord.Phatwo;
    Phatmo = restartRecord.Phatmo;
    Sig_ao = restartRecord.Sig_ao;
    dynfun = restartRecord.dynfun;
    datfun = restartRecord.datfun;
    dynarg = restartRecord.dynarg;
    datarg = restartRecord.datarg;
    options = restartRecord.options;
    S = restartRecord.S;
    C = restartRecord.C;
    tspan = varargin{2};
    tspan = tspan(:)';
else 
    restart = 0;
end
if nargin >= 4,
    if all(isfield(varargin{1}, {'tru','est'})),
        dynfun = varargin{1};
    else
        dynfun.tru = varargin{1};
        dynfun.est = varargin{1};
    end
    if all(isfield(varargin{2}, {'tru','est'})),
        datfun = varargin{2};
    else
        datfun.tru = varargin{2};
        datfun.est = varargin{2};
    end
    tspan = varargin{3};
    if isstruct(varargin{4}),
        Xo = varargin{4}.Xo;
        Xbaro = varargin{4}.Xbaro;
    else
        Xo = varargin{4};
        Xbaro = varargin{4};
    end
end
if nargin >= 5,
    if isstruct(varargin{5}),
        Po = varargin{5}.Po;
        Pbaro = varargin{5}.Pbaro;
    else
        Po = varargin{5};
        Pbaro = varargin{5};
    end
    if isempty(Po)
        Po = 1/eps*eye(length(Xo));
    end
    if isempty(Pbaro)
        Pbaro = 1/eps*eye(length(Xo));
    end
elseif nargin >= 4,
    Po = 1/eps*eye(length(Xo));
    Pbaro = Po;
end
if nargin >=6,
    options = varargin{6};
elseif nargin ~= 2
    options = setOdtbxOptions('OdeSolvOpts',odeset);
end
upvec = getOdtbxOptions(options,'UpdateVectorized',1);
ncases = getOdtbxOptions(options,'MonteCarloCases',1);
niter = getOdtbxOptions(options,'UpdateIterations',1);
refint = getOdtbxOptions(options,'refint',3); 

if nargin >= 7,
    if all(isfield(varargin{7}, {'tru','est'}))
        dynarg = varargin{7};
    else
        dynarg.tru = varargin{7};
        dynarg.est = varargin{7};
    end
elseif nargin >= 4,
    dynarg.tru = [];
    dynarg.est = [];
end
if nargin >= 8,
    if all(isfield(varargin{8}, {'tru','est'}))
        datarg = varargin{8};
    else
        datarg.tru = varargin{8};
        datarg.est = varargin{8};
    end
elseif nargin >= 4,
    datarg.tru = [];
    datarg.est = [];
end

if nargin >= 9,
    if isa(varargin{9},'function_handle'),
        mapfun = varargin{9}; %#ok<NASGU> %TODO
    elseif isa(varargin{9},'numeric') % constant solve-for map
        S = varargin{9};
        C = []; %zeros(0,0,length(tspan)); % in case C is not input, solve for all states
    end
elseif nargin >= 4, % If S & C not input, solve for all states
    S = eye(size(Po));
    C = []; %zeros(0,0,length(tspan));
end
if nargin >= 10, % constant consider map
    C = varargin{10}; %repmat(varargin{10},[1,1,length(tspan)]);
end

if nargout == 0,
    demomode = true;
else
    demomode = false;
end

if testmode,
    switch testmode
        case 1
            dynfun.tru = @rwdyn;
            dynfun.est = @rwdyn;
            datfun.tru = @rwdat;
            datfun.est = @rwdat;
            load('estseq_test1.mat')
            niter = 3;
            options = setOdtbxOptions('MonteCarloSeed',1);
            options = setOdtbxOptions(options,'EditFlag',2);
            options = setOdtbxOptions(options,'UseSmoother',1);

        case 2 % Consider covariance
            dynfun.tru = @irwbdyn;
            dynfun.est = @irwdyn;
            datfun.tru = @irwbdat;
            datfun.est = @irwdat;
            load('estseq_test2.mat')
            niter = 3;
            options = setOdtbxOptions('MonteCarloSeed',2);
            options = setOdtbxOptions(options,'EditFlag',[2 2 2]);
            options = setOdtbxOptions(options,'UseSmoother',1);
            refint = 3;

        case 3 % Estimation using JAT forces
            dynfun.tru = @jatForces_km;
            dynfun.est = dynfun.tru;
            datfun.tru = @gsmeas;
            datfun.est = datfun.tru;
            jOptions    = odtbxOptions('force');
            jOptions    = setOdtbxOptions(jOptions, 'epoch', JATConstant('MJDJ2000') );
            jOptions    = setOdtbxOptions(jOptions, 'cD', 2.2);
            jOptions    = setOdtbxOptions(jOptions, 'cR', 0.7);
            jOptions    = setOdtbxOptions(jOptions, 'mass', 1000);
            jOptions    = setOdtbxOptions(jOptions, 'draga', 20, 'srpArea', 20);
            jOptions    = setOdtbxOptions(jOptions, 'earthGravityModel', '2body');
            jOptions    = setOdtbxOptions(jOptions, 'gravDeg', 2, 'gravOrder', 2);
            jOptions    = setOdtbxOptions(jOptions, 'useSolarGravity', false);
            jOptions    = setOdtbxOptions(jOptions, 'useLunarGravity', false);
            jOptions    = setOdtbxOptions(jOptions, 'useSolarRadiationPressure', false);
            jOptions    = setOdtbxOptions(jOptions, 'useAtmosphericDrag', false);
            jOptions    = setOdtbxOptions(jOptions, 'atmosphereModel', 'HP');
            jOptions    = setOdtbxOptions(jOptions, 'nParameterForHPModel', 2);
            jOptions    = setOdtbxOptions(jOptions, 'f107Daily', 150);
            jOptions    = setOdtbxOptions(jOptions, 'f107Average', 150);
            jOptions    = setOdtbxOptions(jOptions, 'ap', 15);
            dynarg.tru = createJATWorld(jOptions); 
            dynarg.est = dynarg.tru;
            S = eye(6);            % Solve-for map - solve for all 6 states
            Xo = [6878;0.00;0.00;0.00;0.00;8.339];       % km & km/sec                     
            Xbaro = S*Xo;
            Po = diag([1e-2 1e-4 1e-1 1e-4 1e-7 1e-5].^2); % km^2 & km^2/s^2
            Pbaro = S*Po*S';
            C=[];
            epoch   = datenum(2006,12,31,23,59,38.3);
            gsID    = {'ZZOD'};
            gsList  = createGroundStationList('DBS_NDOSL_WGS84_Mod_Example.txt');
            measOptions = odtbxOptions('measurement');
            measOptions = setOdtbxOptions(measOptions,'epoch',epoch);
            measOptions = setOdtbxOptions(measOptions,'useRange',true);
            measOptions = setOdtbxOptions(measOptions,'rangeType','2way');
            measOptions = setOdtbxOptions(measOptions,'useRangerate',true);
            measOptions = setOdtbxOptions(measOptions,'useDoppler',false);
            measOptions = setOdtbxOptions(measOptions,'rSigma',[1e-3 1e-6]);
            measOptions = setOdtbxOptions(measOptions,'useTroposphere',false);
            measOptions = setOdtbxOptions(measOptions,'gsID',gsID);
            measOptions = setOdtbxOptions(measOptions,'gsElevationConstraint',0);
            measOptions = setOdtbxOptions(measOptions,'gsList',gsList);
            datarg.tru  = measOptions;
            datarg.est  = setOdtbxOptions(datarg.tru,'rSigma',3*[1e-3 1e-6]);
            tspan   = 0:10:300; 
            options = odtbxOptions('estimator');
            options = setOdtbxOptions(options, 'UpdateIterations',2,'MonteCarloCases',2,...
                'MonteCarloSeed', 1, 'OdeSolver',@ode113,'OdeSolvOpts',...
                odeset('reltol',1e-9,'abstol',1e-9,'initialstep',10));
            options = setOdtbxOptions(options,'EditFlag',[2 2]);
            options = setOdtbxOptions(options,'MonteCarloCases',2);
            options = setOdtbxOptions(options,'UseSmoother',1);
            niter = 2;
            load('estseq_test4.mat')
            refint = 3;
    end
end

%% Reference Trajectory
% Integrate the reference trajectory and associated variational equations
% over the specified time interval.  Add intermediate sample points between
% each measurement so as to see the effects of the updates.
lents = length(tspan);
if refint < 0 % Variable step integrator to determine intermediate points
    xinit     = Xo;
    tint      = NaN(1,lents*100);
    Xref      = NaN(length(Xo),lents*100);
    tint(1)   = tspan(1); % Time vector including intermediate points
    Xref(:,1) = Xo;      % True states at measurement points tspan only
    ind = 1;
    for i = 1:lents-1
        [ti,xi] = integ(dynfun.tru,tspan(i:i+1),xinit,options,dynarg.tru);
        len = length(ti);
        tint(ind+1:ind+len-1) = ti(2:end)';
        Xref(:,ind+1:ind+len-1) = xi(:,2:end);
        xinit = xi(:,end);
        ind = ind+len-1;
    end
    tint = tint(1:ind);
    Xref = Xref(:,1:ind);
else
    tint = refine(tspan,refint);
    [~,Xref] = integ(dynfun.tru,tint,Xo,options,dynarg.tru);
end
lenti = length(tint);
[~,Xsref] = integ(dynfun.est,tint,Xbaro,options,dynarg.est);

% Indices within tint that point back to tspan, i.e., tint(ispan)=tspan
[~,ispan] = ismember(tspan,tint,'legacy');

Yref = feval(datfun.tru,tspan,Xref(:,ispan),datarg.tru);
Ybar = feval(datfun.est,tspan,Xsref(:,ispan),datarg.est);
[~,Href,R] = ominusc(datfun.tru,tspan,Xref(:,ispan),Yref,options,[],datarg.tru);
[~,Hsref,Rhat] = ominusc(datfun.est,tspan,Xsref(:,ispan),Ybar,options,[],datarg.est);
m = size(Ybar,1);

%% Time tag arrays
% Compute a vector of time tags that account for updates (and possible
% iterations) at each measurement time.

% Accounts for updates/iterations
titer = NaN(1,lenti+lents*(niter));
titer(1:niter+1) = tint(1)*ones(1,niter+1);
ind = niter+1;
for i = 2:lents
    delt = [tint(ispan(i-1)+1:ispan(i)-1) ...
             repmat(tint(ispan(i)),1,niter+1)];
    ldt = length(delt);
    titer(ind+1:ind+ldt) = delt;
    ind = ind+ldt;
end
titer = titer(1:ind);
lentr = length(titer);

% Find indices within titer that point back to tint
[~,iint] = ismember(tint,titer,'legacy');

if ~exist('mapfun','var'),
    ns = size(S(:,:,1),1);
    nc = size(C(:,:,1),1);
    if lentr > 1,
        if size(S,3) > 1 || size(C,3) > 1,
            disp('For time-varying S & C, ESTSRIF requires input of mapfun (currently not implemented).')
            disp('Replicating S(:,:,1) & C(:,:,1) instead.')
            S = S(:,:,1);
            C = C(:,:,1);
        end
        S = repmat(S,[1,1,lentr]);
        if isempty(C),
            C = zeros(0,0,lentr);
        else
            C = repmat(C,[1,1,lentr]);
        end
    end
else % TODO: implement mapfun
    error('mapfun not implemented in this release')
end
n = ns + nc;

%% Perform linear covariance analysis using Kalman Filter methods

if restart
    Po = Pao + Pvo + Pwo + Pmo;
    Pbaro = Phatao + Phatvo + Phatwo + Phatmo;
    
    [P,Pa,Pv,Pw,Pm,Phata,Phatv,Phatw,Phatm,Sig_a,Pdyt]=lincov_kf(...
        tspan,tint,titer,niter,S,C,Po,Pbaro,Xref,Href,Yref,R,Xsref,Hsref,...
        Ybar,Rhat,dynfun,dynarg,demomode,0,options,...
        Pao,Pvo,Pwo,Pmo,Phatao,Phatvo,Phatwo,Phatmo,Sig_ao);
else
    [P,Pa,Pv,Pw,Pm,Phata,Phatv,Phatw,Phatm,Sig_a,Pdyt]=lincov_kf(...
        tspan,tint,titer,niter,S,C,Po,Pbaro,Xref,Href,Yref,R,Xsref,Hsref,...
        Ybar,Rhat,dynfun,dynarg,demomode,0,options);
end

for j = lentr:-1:1,
    Sig_sa(:,:,j) = S(:,:,j)*Sig_a(:,:,j); 
end

%% Monte Carlo Simulation
% Always perform at least one actual simulation as a check against
% linearization problems.  Generate random deviations from the reference as
% initial conditions for each monte carlo case.  Integrate each deviated
% case, and use this as truth for measurement simulation and estimation
% error generation.  Do this after plotting the covariance results, so the
% user can terminate the run if obvious problems occur, since the
% simulation may be slow, especially if a lot of monte carlo cases are
% running.

% Check some estimator options
eopts = chkestopts(options,ncases,m);
% See if UseSmoother flag is set.  If not, the default value is 0, which
% means to not use the smoother.
smooth=getOdtbxOptions(options,'UseSmoother',0);

% Pre-allocate arrays that need to be filled in forward-time order (the
% rest can be fully allocated when created).
[t,X,Xhat,Phat,y,Y,e,dPhat,de,eflag,Pdy,Xstar,Pstar,estar,dPstar,destar] = deal(cell(1,ncases));
[X{:}] = deal(NaN(n,lenti));
[Xhat{:}] = deal(NaN(length(Xbaro),lentr));
[Phat{:}] = deal(NaN([size(Pbaro),lentr]));
[y{:}] = deal(NaN(m,lentr));     % Measurement innovations
[eflag{:}] = deal(NaN(m,lentr));
[Y{:}] = deal(NaN(m,lents));     % True measurements
[Pdy{:}] = deal(NaN(m,m,lentr)); % Measurement innovations covariance

if smooth == 1
    [Xstar{:}] = deal(NaN(length(Xbaro),lentr));
    [Pstar{:}] = deal(NaN([size(Pbaro),lentr]));
end

% Minimally allocate Xmco for the parfor loop, if needed.
if ~restart
    Xmco = deal(cell(1,ncases));
end

% Generate true states and measurements for each case
for j = ncases:-1:1,
    for i = 1:lents,
        if i == 1,
            if restart
                X{j}(:,1) = Xmco(:,j);
            else
                X{j}(:,1) = Xref(:,1) + covsmpl(Po, 1, eopts.monteseed(j));
            end
        else
            for k = ispan(i-1):ispan(i)-1
                [~,xdum,~,sdum] = integ(dynfun.tru,tint(k:k+1),X{j}(:,k),[],dynarg.tru);
                X{j}(:,k+1) = xdum(:,end) + covsmpl(sdum(:,:,end));
                
            end
        end
        Y{j}(:,i) = feval(datfun.tru,tspan(i),X{j}(:,ispan(i)),datarg.tru)+covsmpl(R(:,:,i));
    end
end

sizedouble = 8; %IEEE Coding standards define double precision as 8 bytes for all operating systems

% Minimally allocate these variables for the parfor loop, if needed.
if ~restart
    Xhatmco = NaN(n,ncases);
    Phatmco = NaN(n,n,ncases);
end

% Run SRIF on the measurements generated above
parfor j = 1:ncases,
    
    if restart
        Xhat{j}(:,1) = Xhatmco(:,j);
        Phat{j}(:,:,1) = Phatmco(:,:,j);
    else
        Xhat{j}(:,1) = Xbaro;    % The filter i.c. is always the same
        Phat{j}(:,:,1) = Pbaro;
    end
    
    % Convert initial estimate and covariance to information pair
    Rbar=inv(chol(Phat{j}(:,:,1),'lower'));
    thisint = 1;
    
    
    %Initialize temporary storage for variables to be used in smoother
    %Each case will have its own temporary file and memory map
    if smooth == 1
        %Initialize temporary storage for variables to be used in smoother
        tempfile=tempname;  %get random temporary file name
        fid=fopen(tempfile,'w');  %open temporary file
        fwrite(fid,NaN([size(Pbaro),lentr]),'double');  %for storage of STM's
        fwrite(fid,NaN([size(Pbaro),lentr]),'double');  %for storage of Rwbar
        fwrite(fid,NaN([size(Pbaro),lentr]),'double');  %for storage of Rwxbar
        fclose(fid);
        
        %Initialize memory map of file
        filemap=memmapfile(tempfile,'Format',{ ...
            'double' [size(Pbaro),lentr] 'Phi'; ...
            'double' [size(Pbaro),lentr] 'Rwbar'; ...
            'double' [size(Pbaro),lentr] 'Rwxbar'},'Writable',true);
        
    end
    
    for i = 1:lents,
                
        % Measurement update niter times
        Rhat = Rbar;
        for k = (thisint(end)+1):iint(ispan(i)) %#ok<PFBNS>
            
            if upvec == 1
                [Xhat{j}(:,k),Rhat,Phat{j}(:,:,k),eflag{j}(:,k),y{j}(:,k),Pdy{j}(:,:,k)] = srifmeas(...
                    datfun.est,tspan(i),Xhat{j}(:,k-1),Rhat,Phat{j}(:,:,k-1),Y{j}(:,i),...
                    options,eopts.eflag,eopts.eratio,datarg.est); %#ok<PFBNS>
            else
                Xhat_tmp = Xhat{j}(:,k-1);
                Rhat_tmp = Rhat;
                Phat_tmp = Phat{j}(:,:,k-1);

                % This assumes that there are always the same number of measurements for
                % all cases for all time.
                for bb=1:m
                    [Xhat_tmp,Rhat_tmp,Phat_tmp,eflag{j}(bb,k),y{j}(bb,k),Pdy{j}(bb,bb,k)] = srifmeas(...
                        datfun.est,tspan(i),Xhat_tmp,Rhat_tmp,Phat_tmp,Y{j}(:,i),...
                        options,eopts.eflag,eopts.eratio,datarg.est,bb);
                end
                Xhat{j}(:,k) = Xhat_tmp;
                Rhat = Rhat_tmp;
                Phat{j}(:,:,k) = Phat_tmp;
            end

        end
        
        % Save last estimate, covariance, and root of information matrix in
        % the last iterative spots if smoothing is desired
        if (i==lents) && (smooth == 1)
            
            Xhatlast_tmp=Xhat{j}(:,lentr);
            Phatlast_tmp=Phat{j}(:,:,lentr);
            
            Xstar{j}(:,lentr) = Xhatlast_tmp;
            Pstar{j}(:,:,lentr) = Phatlast_tmp;
            
            for ii = 1:niter
                Xstarlast_tmp=Xstar{j}(:,lentr);
                Pstarlast_tmp=Pstar{j}(:,:,lentr);
                
                Xstar{j}(:,lentr-ii)=Xstarlast_tmp;
                Pstar{j}(:,:,lentr-ii)=Pstarlast_tmp;
            end
            Rstar=Rhat; %save the last square root of information matrix
        end
        
        % Time update
        if i < lents
            thisint = iint(ispan(i)):iint(ispan(i+1))-niter;
            
            [~,x_integ,Phi_integ,Qd_integ]=integ(dynfun.est,titer(thisint),Xhat{j}(:,thisint(1)),...
                [],dynarg.est); %#ok<PFBNS>
            if length(thisint) == 2 % This is because for time vector of length 2, ode outputs >2
                x_integ = [x_integ(:,1) x_integ(:,end)];
                Phi_integ(:,:,2) = Phi_integ(:,:,end);
                Qd_integ(:,:,2) = Qd_integ(:,:,end);
            end
            
            %save data in memory map for smoothing if necessary
            if smooth == 1
                filemap.Data.Phi(:,:,thisint)=Phi_integ;
            end
            
            Xhat{j}(:,thisint) = x_integ;
            for k = 2:length(thisint)
                Qd_integ(:,:,k) = (Qd_integ(:,:,k) + Qd_integ(:,:,k)')/2;
                Rbar = Rhat/Phi_integ(:,:,k); % Always refer back to Rhat from meas update
                if all(eig(Qd_integ(:,:,k))>0)  % Positive definite??
                    Rw=inv(chol(Qd_integ(:,:,k),'lower'));
                    A = [Rw zeros(ns,ns);-Rbar Rbar];
                    [~,T] = qr(A);
                    
                    %save data in memory map for smoothing if necessary
                    if smooth == 1
                        filemap.Data.Rwbar(:,:,thisint(k))=T(1:ns,1:ns);
                        filemap.Data.Rwxbar(:,:,thisint(k))=T(1:ns,ns+1:2*ns);
                    end
                    
                    %mapped square root
                    Rbar = T(ns+1:2*ns,ns+1:2*ns);
                end
                Rbari = Rbar\eye(ns);
                Phat{j}(:,:,thisint(k)) = Rbari*Rbari';
            end
            
        end
        
    end

    
    %smoother portion
    if smooth == 1
        
        %turn off ability to write to memory map before smoother loop
        filemap.Writable=false;
    
        %go through each time interval
        for s=lents-1:-1:1
            
            thisint = iint(ispan(s)):iint(ispan(s+1))-niter;
            
            %read in data necessary for this time interval
            %read in Phi's
            filemap.Offset=ns*ns*sizedouble*(thisint(1)-1);  %set offset
            filemap.Format={'double' [ns,ns,length(thisint)] 'Phi'};
            filemap.Repeat=1;
            Phi_filt=filemap.Data.Phi;  %make copy of data
            
            %read in Rwbar's
            filemap.Offset=ns*ns*sizedouble*lentr ...
                +ns*ns*sizedouble*(thisint(1)-1);  %Skip all of Phi also
            filemap.Format={'double' [ns,ns,length(thisint)] 'Rwbar'};
            
            Rwbar_filt=filemap.Data.Rwbar;  %make copy of data
            
            %read in Rwxbar's
            filemap.Offset=(ns*ns*sizedouble*lentr)*2 ...
                +ns*ns*sizedouble*(thisint(1)-1);  %Skip all of Phi and Rwbar
            filemap.Format={'double' [ns,ns,length(thisint)] 'Rwxbar'};
            
            Rwxbar_filt=filemap.Data.Rwxbar;  %make copy of data
            
            %last for this interval
            Rstarlast=Rstar;
            
            %last zstar for this interval
            zstarlast = Rstarlast*(Xstar{j}(:,thisint(end))-Xhat{j}(:,thisint(end)));
            
            %go through each subinterval from the time span refinement
            for k=(length(thisint)-1):-1:1
                
                Phi=Phi_filt(:,:,k)\Phi_filt(:,:,end);  %STM for this sub interval
                
                if isnan(Rwbar_filt(:,:,end))  %there is no process noise
                    zstar=zstarlast;
                    Rstar=Rstarlast*Phi;
                else %there is process noise
                    %Form augmented matrix
                    Asmoother = [Rwbar_filt(:,:,end)+Rwxbar_filt(:,:,end) Rwxbar_filt(:,:,end)*Phi zeros(ns,1);
                        Rstarlast Rstarlast*Phi zstarlast];
                    
                    %solve
                    [~,Tsmoother]= qr(Asmoother);
                    
                    %extract
                    Rstar = Tsmoother(ns+1:2*ns,ns+1:2*ns);
                    zstar = Tsmoother(ns+1:2*ns,2*ns+1);
                end
                
                %save
                dxstar = Rstar\zstar;
                Xhat_tmp=Xhat{j}(:,thisint(k));
                Xstar{j}(:,thisint(k))=Xhat_tmp+dxstar;
                
                Rstari = Rstar\eye(ns);
                Pstar{j}(:,:,thisint(k)) = Rstari*Rstari';
            end
            
            %fill in the repeated time slots with last smoothed solution
            for i = 1:niter
                Xstar_tmp=Xstar{j}(:,thisint(1));
                Pstar_tmp=Pstar{j}(:,:,thisint(1));
                
                Xstar{j}(:,thisint(1)-i)=Xstar_tmp;
                Pstar{j}(:,:,thisint(1)-i)=Pstar_tmp;
            end
        end
    
        %destroy file and memory map for this case
        filemap=[];
        delete(tempfile)
    end
end

%% Estimation Error Ensemble
% Generate the time series of estimation errors for each
% case.  Use estval to plot these data if no output arguments are supplied.

P = scrunch(P);
for j = ncases:-1:1,
    t{j} = titer;
    Phat{j} = scrunch(Phat{j}); % Need to look at solve for only
    if smooth == 1
        Pstar{j} = scrunch(Pstar{j});
    end
    for i = lenti:-1:1,
        % This misses any update iterations
        e{j}(:,iint(i)) = Xhat{j}(:,iint(i)) - S(:,:,iint(i))*X{j}(:,i);
        if smooth == 1
            estar{j}(:,iint(i)) = Xstar{j}(:,iint(i)) - S(:,:,iint(i))*X{j}(:,i);
        end
        % Fill in iterations if required
        if i == 1,
            thisint = 1;
        else
            thisint = iint(i-1)+1:iint(i)-1;
        end
        for k = thisint,
            e{j}(:,k) = Xhat{j}(:,k) - S(:,:,k)*X{j}(:,i);
            if smooth == 1
                estar{j}(:,k) = Xstar{j}(:,k) - S(:,:,k)*X{j}(:,i);
            end
        end
    end
end

%% Display results of demo cases
if demomode,
    estval(t,e,Phat,P,gcf)
    estval(t,estar,Pstar,P,gcf)
    disp('You are in the workspace of ESTSRIF; type ''return'' to exit.')
    keyboard
end

%% Self-test regression tests
if testmode && ~demomode,
    P_test_array = P_test; % Assign to an array variable so Matlab doesn't complain
    
    switch testmode
        case 1
            load('estseq_test1.mat')
        case 2
            load('estseq_test2.mat')
        case 3
            load('estseq_test4.mat')
    end
    [dPhat{:}] = deal(NaN(size(Phat)));
    [dPstar{:}] = deal(NaN(size(Pstar)));
    
    [de{:}] = deal(NaN(size(e)));
    [destar{:}] = deal(NaN(size(estar)));
    
    Pfail = zeros(length(titer),ncases);
    Pstarfail = zeros(length(titer),ncases);
    
    efail = zeros(length(titer),ncases,ns);
    estarfail = zeros(length(titer),ncases,ns);
    
    for k = ncases:-1:1,
        dPhat{k} = Phat_test{k} - Phat{k}; %#ok<USENS>
        dPstar{k} = Pstar_test{k} - Pstar{k};
        %sPhat{k} = Phat_test{k} + Phat{k}; %#ok<AGROW>
        de{k} = e_test{k} - e{k}; %#ok<USENS>
        destar{k} = estar_test{k} - estar{k}; %#ok<USENS>
        % Is each error sample within prob of 1e-9 of its corresponding test
        % value?  Is each Phat sample "close enough," in terms of the
        % matrix 2-norm (largest singular value) to its test value?
        try
            chistat = chi2inv(1-1e-9,ns);
            vectest = true;
        catch %#ok<CTCH>
            chistat = 37.325;
            vectest = false;
        end
        for i = length(titer):-1:1,
            SPS = S(:,:,i)*unscrunch(P_test_array(:,i))*S(:,:,i)';  
            
            dek=de{k}(:,i);
            dekstar=destar{k}(:,i);
            
            if vectest,
                efail(i,k,1) = ...
                    dek'/SPS*dek > chistat;
                    %dek'*inv(SPS)*dek > chistat; 
                estarfail(i,k,1) = ...
                    dekstar'/SPS*dekstar > chistat;
            else
                for j = ns:-1:1,
                    efail(i,k,j) = dek(j)^2/SPS(j,j) > 37.325; 
                    estarfail(i,k,j) = dekstar(j)^2/SPS(j,j) > 37.325;
                end
            end
            Pfail(i,k) = ...
                norm(unscrunch(dPhat{k}(:,i))) > ...
                0.1*norm(unscrunch(Phat_test{k}(:,i))); 
            Pstarfail(i,k) = ...
                norm(unscrunch(dPstar{k}(:,i))) > ...
                0.1*norm(unscrunch(Pstar_test{k}(:,i)));
        end
    end
    fail = logical([...
        any(any(any(abs(P_test - P) > 4e-10))), ...
        any(any(any(abs(Pa_test - Pa) > 1e-10))), ...
        any(any(any(abs(Pv_test - Pv) > 1e-10))),...
        any(any(any(abs(Pw_test - Pw) > 4e-10))), ...
        any(any(any(abs(Phatw_test - Phatw) > 1e-10))), ...
        any(any(any(abs(Phatv_test - Phatv) > 1e-10))), ...
        any(any(any(abs(Phata_test - Phata) > 1e-10))), ...
        any(any(any(abs(Sig_sa_test - Sig_sa) > 2e-10))), ...
        any(any(any(efail))), ...
        any(any(any(estarfail))), ...
        any(any(Pfail)), ...
        any(any(Pstarfail))]);
    varargout{1} = fail;
end

%% Output results
if nargout >= 3,
    varargout{1} = t;
    varargout{2} = Xhat;
    varargout{3} = Phat;
end
if nargout >= 4,
    varargout{4} = e;
end
if nargout >= 5,
    varargout{5} = y;
end
if nargout >= 6,
    varargout{6} = Pa;
    varargout{7} = Pv;
    varargout{8} = Pw;
    varargout{9} = Phata;
    varargout{10} = Phatv;
    varargout{11} = Phatw;
end
if nargout >= 12,
    varargout{12} = Sig_sa;
end
if(nargout >= 13)
    varargout{13} = eflag;
end
if nargout >= 14,
    varargout{14} = Pdy;
end
if nargout >= 15,
    varargout{15} = Pdyt;
end
if nargout >= 16,
    varargout{16} = Xstar;
    varargout{17} = Pstar;
end
if nargout >= 18,
    varargout{18} = estar;
end
if nargout >= 19,
    varargout{19} = Pm;
    varargout{20} = Phatm;
end
if nargout >= 21,
    restartRecord.Pao = Pa(:,:,end);
    restartRecord.Pvo = Pv(:,:,end);
    restartRecord.Pwo = Pw(:,:,end);
    restartRecord.Pmo = Pm(:,:,end);
    restartRecord.Phatao = Phata(:,:,end);
    restartRecord.Phatvo = Phatv(:,:,end);
    restartRecord.Phatwo = Phatw(:,:,end);
    restartRecord.Phatmo = Phatm(:,:,end);
    restartRecord.Xrefo = Xref(:,end);
    restartRecord.Xsrefo = Xsref(:,end);
    for i = ncases:-1:1
        restartRecord.Xo(:,i) = X{i}(:,end);
        restartRecord.Xhato(:,i) = Xhat{i}(:,end);
        restartRecord.Phato(:,:,i) = unscrunch(Phat{i}(:,end));
    end
    restartRecord.Sig_ao = Sig_a(:,:,end);
    restartRecord.dynfun = dynfun;
    restartRecord.datfun = datfun;
    restartRecord.dynarg = dynarg;
    restartRecord.datarg = datarg;
    restartRecord.options = options;
    restartRecord.S = S(:,:,1);
    restartRecord.C = C(:,:,1);
    varargout{21} = restartRecord;
end
if nargout >= 22,
    varargout{22} = S;
    varargout{23} = C;
end

end % function

%% Measurement update function for SRIF                                   
function [xhat,Rhat,Phat,eflag_isel,dy_isel,Pdy_isel] = srifmeas(datfun,t,xbar,Rbar,...
          Pbar,y,options,eflag,eratio,datarg,isel)
%      
% Equivalent of kalmup for ESTSRIF
%
% S. Hur-Diaz
% Emergent Space Technologies
m = length(y);
ns = size(xbar,1);
zx = zeros(ns,1);
Pdy = NaN(m,m);

if ~exist('isel', 'var') || isempty(isel)
    isel = 1:m;
end

process = true(length(isel),1);

% Calculate predicted measurement
[dy,H,R,Pdy]=ominusc(datfun,t,xbar,y,options,Pbar,datarg);

if length(eflag) > 1
    eflag = eflag(isel);
end
if length(eratio) > 1
    eratio = eratio(isel);
end

% Perform measurement editing
[process,eflags] = editmeas(process,dy(isel),Pdy(isel,isel),eflag,eratio);
iuse = isel(process == true);

if ~isempty(iuse)
    
    % Whiten measurements
    L = chol(R(iuse,iuse),'lower');
    Hw = L\H(iuse,:);
    dyw = L\dy(iuse);
    
    A = [Rbar zx;Hw dyw];
    [~,T] = qr(A);           % T is upper triangular
    Rhat = T(1:ns,1:ns);
    zhat = T(1:ns,ns+1);
    dxhat = Rhat\zhat;
    xhat = xbar + dxhat;
    Rinv = Rhat\eye(ns);
    Phat = Rinv*Rinv';
    %         Rbar = Rhat;
else
    Rhat = Rbar;
    xhat = xbar;
    Phat = Pbar;
    iuse = [];
end

eflag_isel = eflags;
dy_isel = dy(isel);
Pdy(iuse,iuse) = H(iuse,:)*Pbar*H(iuse,:)' + R(iuse,iuse);
Pdy_isel = Pdy(isel,isel);

end

% ESTSRIF helper functions
function y = refine(u,refine)
y = [reshape([u(1:end-1);repmat(u(1:end-1),refine,1)+...
    cumsum(repmat(diff(u)/(refine+1),refine,1),1)],[],1);u(end)]';
end

% Self-test user functions
% Dynamics function for case 1: true and estimate
function [Xdot,A,Q] = rwdyn(t,X,q)
el = length(t);
A = zeros(1,1,el);
Xdot = zeros(size(X));
Q = q*ones(1,1,el);
end

% Dynamics function for case 2: true
function [Xdot,A,Q] = irwbdyn(t,X,q)
el = length(t);
A([1:3 7:8],[4:6 8]) = eye(5,4);
Xdot = A*X;
A = repmat(A,[1 1 el]);
Q([4:6 8],[4:6 8]) = q*eye(4);
Q = repmat(Q,[1 1 el]);
end

% Dynamics function for case 2: estimate, solve for only
function [Xdot,A,Q] = irwdyn(t,X,q)
el = length(t);
A(:,4:6) = eye(6,3);
Xdot = A*X;
A = repmat(A,[1 1 el]);
Q(4:6,4:6) = q*eye(3);
Q = repmat(Q,[1 1 el]);
end

% Measurement function for case 1: true and estimate
function [Y,H,R] = rwdat(t,X,r)
Y = X;
H = ones(1,1,length(t));
R = r*ones(1,1,length(t));
end

% Measurement function for case 2: true
function [Y,H,R] = irwbdat(t,X,r)
el = length(t);
H = [eye(3) zeros(3,3) -ones(3,1) zeros(3,1)];
Y = H*X;
H = repmat(H,[1 1 el]);
R = r*repmat(eye(3),[1 1 el]);
end

% Measurement function for case 2: estimate, solve for only
function [Y,H,R] = irwdat(t,X,r)
el = length(t);
H = [eye(3) zeros(3,3)];
Y = H*X;
H = repmat(H,[1 1 el]);
R = r*repmat(eye(3),[1 1 el]);
end
